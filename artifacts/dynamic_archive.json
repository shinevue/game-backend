{"actor_deno.ts":"// This file is only imported when the runtime is `Deno`. See `actor_cf.ts` in the same directory.\n\nimport { ActorDriver } from \"./runtime/src/runtime/actor.ts\";\n\nconst ENCODER = new TextEncoder();\nconst ACTOR_STORAGE: Map<string, {\n\tactor: ActorBase;\n\tstorage: Map<string, any>;\n}> = new Map();\n\nexport const ACTOR_DRIVER = {\n\tasync getId(moduleName: string, actorName: string, label: string) {\n\t\tconst storageId = config.modules[moduleName].actors[actorName].storageId;\n\t\tconst name = `%%${storageId}%%${label}`;\n\n\t\treturn await hash(name);\n\t},\n\tasync getActor(moduleName: string, actorName: string, label: string) {\n\t\tconst id = await ACTOR_DRIVER.getId(moduleName, actorName, label);\n\t\tconst entry = ACTOR_STORAGE.get(id);\n\n\t\tif (entry == undefined) throw new Error(\"actor not initialized\");\n\n\t\treturn entry.actor;\n\t},\n\tasync createActor(moduleName: string, actorName: string, label: string, input: any) {\n\t\tconst id = await ACTOR_DRIVER.getId(moduleName, actorName, label);\n\n\t\t// Create actor instance\n\t\tconst actorClass = config.modules[moduleName].actors[actorName].actor;\n\t\tconst actor = new actorClass(new StorageProxy(id), actorClass.buildState(input));\n\n\t\tACTOR_STORAGE.set(id, {\n\t\t\tactor,\n\t\t\tstorage: new Map(),\n\t\t});\n\t},\n\tasync callActor(stub: ActorBase, fn: string, args: any[]) {\n\t\tlet res = (stub as any)[fn](...args);\n\t\tif (res instanceof Promise) res = await res;\n\n\t\treturn res;\n\t},\n\tasync actorExists(moduleName: string, actorName: string, label: string) {\n\t\tconst id = await ACTOR_DRIVER.getId(moduleName, actorName, label);\n\n\t\treturn ACTOR_STORAGE.has(id);\n\t},\n};\n\n/**\n * Actor implementation that user-made actors will extend.\n * Not meant to be instantiated.\n */\nexport abstract class ActorBase {\n\tstatic buildState(_input: unknown): any {\n\t\tthrow Error(\"unimplemented\");\n\t}\n\n\tconstructor(public storage: StorageProxy, public state: unknown) {}\n}\n\n// Emulates the storage from cloudflare durable objects\nexport class StorageProxy {\n\tconstructor(private id: string) {}\n\n\tasync get(keys: string | string[]): Promise<Map<string, any> | any> {\n\t\tif (keys instanceof Array) {\n\t\t\treturn new Map(keys.map((key) => [key, ACTOR_STORAGE.get(this.id)!.storage.get(key)]));\n\t\t} else {\n\t\t\treturn ACTOR_STORAGE.get(this.id)!.storage.get(keys);\n\t\t}\n\t}\n\n\tasync put(key: string, value: any) {\n\t\tACTOR_STORAGE.get(this.id)!.storage.set(key, value);\n\t}\n\n\tasync delete(keys: string | string[]) {\n\t\tconst handle = ACTOR_STORAGE.get(this.id)!.storage;\n\n\t\tif (keys instanceof Array) {\n\t\t\treturn keys.map((key) => {\n\t\t\t\tconst exists = handle.has(key);\n\n\t\t\t\tif (exists) handle.delete(key);\n\n\t\t\t\treturn exists;\n\t\t\t}).reduce((s, a) => s + Number(a), 0);\n\t\t} else {\n\t\t\tconst exists = handle.has(keys);\n\n\t\t\tif (exists) handle.delete(keys);\n\n\t\t\treturn exists;\n\t\t}\n\t}\n}\n\nasync function hash(input: string) {\n\tconst data = ENCODER.encode(input);\n\tconst hash = await crypto.subtle.digest(\"SHA-256\", data);\n\tconst hashString = Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n\n\treturn hashString;\n}\n","actor_cf.ts":"// This file is only imported when the runtime is `Cloudflare`. See `actor.ts` in the same directory.\n\nimport { DurableObject } from \"cloudflare:workers\";\nimport { ActorDriver } from \"./runtime/src/runtime/actor.ts\";\n\nexport const ACTOR_DRIVER: ActorDriver = {\n\tasync getId(moduleName: string, actorName: string, label: string) {\n\t\tconst storageId = config.modules[moduleName].actors[actorName].storageId;\n\t\tconst name = `%%${storageId}%%${label}`;\n\t\tconst doHandle = Deno.env.get(\"__GLOBAL_DURABLE_OBJECT\") as any as DurableObjectHandle;\n\n\t\t// throw new Error(`${name}\\n${doHandle.idFromName(name)}`);\n\n\t\treturn doHandle.idFromName(name);\n\t},\n\tasync getActor(moduleName: string, actorName: string, label: string) {\n\t\tconst id = await ACTOR_DRIVER.getId(moduleName, actorName, label);\n\t\tconst doHandle = Deno.env.get(\"__GLOBAL_DURABLE_OBJECT\") as any as DurableObjectHandle;\n\t\tconst doStub = doHandle.get(id) as __GlobalDurableObject;\n\n\t\treturn doStub;\n\t},\n\tasync createActor(moduleName: string, actorName: string, label: string, input: any) {\n\t\tconst stub = await ACTOR_DRIVER.getActor(moduleName, actorName, label);\n\n\t\tawait stub.__init(moduleName, actorName, input);\n\n\t\treturn stub;\n\t},\n\tasync callActor(stub: __GlobalDurableObject, fn: string, args: any[]) {\n\t\treturn await stub.__call(fn, args);\n\t},\n\tasync actorExists(moduleName: string, actorName: string, label: string) {\n\t\tconst stub = await ACTOR_DRIVER.getActor(moduleName, actorName, label);\n\n\t\treturn await stub.__initialized();\n\t},\n};\n\nexport class __GlobalDurableObject extends DurableObject {\n\tasync __init(moduleName: string, actorName: string, input: any) {\n\t\t// Store module name and actor name\n\t\tawait this.ctx.storage.put(\"__path\", [moduleName, actorName]);\n\n\t\t// Build initial state\n\t\tconst state = config.modules[moduleName].actors[actorName].actor.buildState(input);\n\t\tawait this.ctx.storage.put(\"state\", state);\n\t}\n\n\tasync __initialized() {\n\t\treturn await this.ctx.storage.get(\"__path\") != undefined;\n\t}\n\n\tasync __call(fn: string, args: any[]): Promise<any> {\n\t\tconst storageRes = await this.ctx.storage.get([\"state\", \"__path\"]);\n\t\tconst state = storageRes.get(\"state\");\n\t\tif (state == undefined) throw Error(\"actor not initiated\");\n\n\t\t// Create actor instance\n\t\tconst [moduleName, actorName] = storageRes.get(\"__path\");\n\n\t\tconst actorClass = config.modules[moduleName].actors[actorName].actor;\n\t\tconst actor = new actorClass(this.ctx.storage, state);\n\n\t\t// Run actor function\n\t\tlet res = (actor as any)[fn](...args);\n\t\tif (res instanceof Promise) res = await res;\n\n\t\t// Update state\n\t\tawait this.ctx.storage.put(\"state\", actor!.state);\n\n\t\treturn res;\n\t}\n}\n\n/**\n * Actor implementation that user-made actors will extend.\n * Not meant to be instantiated.\n */\nexport abstract class ActorBase {\n\tstatic buildState(_input: unknown): any {\n\t\tthrow Error(\"buildState unimplemented\");\n\t}\n\n\tprivate constructor(public storage: DurableObjectStorage, public state: unknown) {}\n}\n\n// TODO: Replace with imported types, maybe from denoflare\ndeclare type DurableObjectCtx = {\n\tstorage: DurableObjectStorage;\n};\ndeclare class DurableObjectStorage {\n\tget(keys: string | string[]): Promise<Map<string, any> | any>;\n\tput(key: string, value: any): Promise<void>;\n\tdelete(keys: string | string[]): Promise<number | boolean>;\n}\ndeclare class DurableObjectHandle {\n\tidFromName(name: string): DurableObjectId;\n\tget(id: DurableObjectId): DurableObject;\n}\ndeclare type DurableObjectId = any;\ndeclare type DurableObjectEnv = any;\n\ndeclare class DurableObject {\n\tprotected ctx: DurableObjectCtx;\n\tprotected env: DurableObjectEnv;\n}\n"}